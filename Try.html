<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Enhanced Particle Background</title>
<style>
  body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #0F1119;
    font-family: Arial, sans-serif;
  }

  .particle-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }

  .particle {
    position: absolute;
    will-change: transform;
    transition: transform 0.8s ease-out, opacity 0.8s ease-out;
  }

  .circle {
    border-radius: 50%;
  }

  .square {
    border-radius: 4px;
  }

  .triangle {
    width: 0 !important;
    height: 0 !important;
    background-color: transparent !important;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-bottom: 17px solid #6C5CE7;
  }

  .star {
    clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
  }

  .controls {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: rgba(26, 28, 42, 0.8);
    padding: 15px;
    border-radius: 10px;
    color: white;
    z-index: 100;
    width: 250px;
  }

  .control-group {
    margin-bottom: 15px;
  }

  .control-label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
  }

  .control-input {
    width: 100%;
    padding: 5px;
    margin-bottom: 5px;
  }

  .color-presets {
    display: flex;
    gap: 5px;
    margin-top: 5px;
  }

  .color-preset {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
  }

  .color-preset.active {
    border-color: white;
  }

  .shape-options {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    margin-top: 5px;
  }

  .shape-option {
    padding: 5px 10px;
    background-color: rgba(108, 92, 231, 0.3);
    border-radius: 15px;
    cursor: pointer;
    font-size: 12px;
  }

  .shape-option.active {
    background-color: rgba(108, 92, 231, 0.8);
  }

  .stats {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    padding: 10px;
    border-radius: 5px;
    font-size: 12px;
  }
</style>
</head>
<body>
<div class="particle-container" id="particle-container"></div>

<div class="controls" id="controls">
  <h3>Particle Settings</h3>
  
  <div class="control-group">
    <label class="control-label">Particle Count: <span id="count-value">60</span></label>
    <input type="range" class="control-input" id="particle-count" min="20" max="200" value="60">
  </div>
  
  <div class="control-group">
    <label class="control-label">Size Range: <span id="size-value">3-12px</span></label>
    <input type="range" class="control-input" id="min-size" min="1" max="10" value="3">
    <input type="range" class="control-input" id="max-size" min="5" max="20" value="12">
  </div>
  
  <div class="control-group">
    <label class="control-label">Speed: <span id="speed-value">1</span></label>
    <input type="range" class="control-input" id="speed" min="0.2" max="3" step="0.1" value="1">
  </div>
  
  <div class="control-group">
    <label class="control-label">Mouse Interaction: <span id="interaction-value">150px</span></label>
    <input type="range" class="control-input" id="interaction-radius" min="50" max="300" value="150">
  </div>
  
  <div class="control-group">
    <label class="control-label">Color Scheme</label>
    <div class="color-presets">
      <div class="color-preset active" style="background: linear-gradient(45deg, #6C5CE7, #00D2D3, #FF7675);" data-colors="#6C5CE7,#00D2D3,#FF7675"></div>
      <div class="color-preset" style="background: linear-gradient(45deg, #2ecc71, #1abc9c, #3498db);" data-colors="#2ecc71,#1abc9c,#3498db"></div>
      <div class="color-preset" style="background: linear-gradient(45deg, #e74c3c, #e67e22, #f1c40f);" data-colors="#e74c3c,#e67e22,#f1c40f"></div>
      <div class="color-preset" style="background: linear-gradient(45deg, #9b59b6, #8e44ad, #2980b9);" data-colors="#9b59b6,#8e44ad,#2980b9"></div>
      <div class="color-preset" style="background: linear-gradient(45deg, #ecf0f1, #bdc3c7, #95a5a6);" data-colors="#ecf0f1,#bdc3c7,#95a5a6"></div>
    </div>
  </div>
  
  <div class="control-group">
    <label class="control-label">Shapes</label>
    <div class="shape-options">
      <div class="shape-option active" data-shape="circle">Circles</div>
      <div class="shape-option active" data-shape="square">Squares</div>
      <div class="shape-option active" data-shape="triangle">Triangles</div>
      <div class="shape-option active" data-shape="star">Stars</div>
    </div>
  </div>
</div>

<div class="stats" id="stats">
  FPS: <span id="fps">60</span> | Particles: <span id="particle-count-display">60</span>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Get DOM elements
    const particleContainer = document.getElementById('particle-container');
    const countValue = document.getElementById('count-value');
    const sizeValue = document.getElementById('size-value');
    const speedValue = document.getElementById('speed-value');
    const interactionValue = document.getElementById('interaction-value');
    const fpsDisplay = document.getElementById('fps');
    const particleCountDisplay = document.getElementById('particle-count-display');
    
    // Configuration object
    const config = {
      count: 60,
      minSize: 3,
      maxSize: 12,
      speed: 1,
      interactionRadius: 150,
      colors: ['#6C5CE7', '#00D2D3', '#FF7675'],
      shapes: ['circle', 'square', 'triangle', 'star'],
      minOpacity: 0.05,
      maxOpacity: 0.2
    };
    
    // Particles array
    let particles = [];
    
    // Mouse position
    let mouseX = 0;
    let mouseY = 0;
    let isMouseMoving = false;
    let mouseMovingTimeout;
    
    // FPS tracking
    let lastTimestamp = 0;
    let fpsArray = [];
    
    // Create particles
    function createParticles() {
      // Clear existing particles
      while (particleContainer.firstChild) {
        particleContainer.removeChild(particleContainer.firstChild);
      }
      particles = [];
      
      // Create new particles
      for (let i = 0; i < config.count; i++) {
        createParticle();
      }
      
      // Update display
      particleCountDisplay.textContent = particles.length;
    }
    
    function createParticle() {
      const particle = document.createElement('div');
      particle.className = 'particle';
      
      // Random shape
      const shape = config.shapes[Math.floor(Math.random() * config.shapes.length)];
      particle.classList.add(shape);
      
      // Random size
      const size = Math.random() * (config.maxSize - config.minSize) + config.minSize;
      
      // Random position
      const x = Math.random() * window.innerWidth;
      const y = Math.random() * window.innerHeight;
      
      // Random opacity
      const opacity = Math.random() * (config.maxOpacity - config.minOpacity) + config.minOpacity;
      
      // Random color
      const color = config.colors[Math.floor(Math.random() * config.colors.length)];
      
      // Set styles
      particle.style.width = `${size}px`;
      particle.style.height = `${size}px`;
      particle.style.left = `${x}px`;
      particle.style.top = `${y}px`;
      particle.style.opacity = opacity.toString();
      
      if (shape === 'triangle') {
        // For triangles, set the border sizes proportionally to the particle size
        particle.style.borderLeftWidth = `${size/2}px`;
        particle.style.borderRightWidth = `${size/2}px`;
        particle.style.borderBottomWidth = `${size * 0.866}px`; // height of equilateral triangle
        particle.style.borderBottomColor = color;
      } else {
        particle.style.backgroundColor = color;
      }
      
      particleContainer.appendChild(particle);
      
      // Store particle properties
      const particleObj = {
        element: particle,
        x: x,
        y: y,
        size: size,
        speedX: (Math.random() * 2 - 1) * config.speed,
        speedY: (Math.random() * 2 - 1) * config.speed,
        opacity: opacity,
        color: color,
        shape: shape,
        baseX: x,
        baseY: y,
        density: (Math.random() * 30) + 10,
        angle: Math.random() * 360 // For rotation
      };
      
      particles.push(particleObj);
      return particleObj;
    }
    
    // Animation loop
    function animateParticles(timestamp) {
      // Calculate FPS
      if (lastTimestamp) {
        const fps = 1000 / (timestamp - lastTimestamp);
        fpsArray.push(fps);
        if (fpsArray.length > 30) fpsArray.shift();
        
        const averageFps = Math.round(fpsArray.reduce((sum, value) => sum + value, 0) / fpsArray.length);
        fpsDisplay.textContent = averageFps;
      }
      lastTimestamp = timestamp;
      
      particles.forEach(particle => {
        // Update position
        particle.x += particle.speedX;
        particle.y += particle.speedY;
        
        // Boundary check with bounce effect
        if (particle.x > window.innerWidth || particle.x < 0) {
          particle.speedX *= -1;
        }
        
        if (particle.y > window.innerHeight || particle.y < 0) {
          particle.speedY *= -1;
        }
        
        // Mouse interaction
        if (isMouseMoving) {
          let dx = mouseX - particle.x;
          let dy = mouseY - particle.y;
          let distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < config.interactionRadius) {
            // Calculate force direction
            const forceDirectionX = dx / distance;
            const forceDirectionY = dy / distance;
            
            // Calculate force strength
            const force = (config.interactionRadius - distance) / config.interactionRadius;
            
            // Apply force with density factor
            const directionX = forceDirectionX * force * particle.density * 0.2;
            const directionY = forceDirectionY * force * particle.density * 0.2;
            
            // Move particle away from mouse
            particle.x -= directionX;
            particle.y -= directionY;
          }
        } else {
          // Gradually return to base position when not affected by mouse
          particle.x += (particle.baseX - particle.x) * 0.01;
          particle.y += (particle.baseY - particle.y) * 0.01;
        }
        
        // Rotate particles (especially for squares, triangles, and stars)
        if (particle.shape !== 'circle') {
          particle.angle += 0.2 * (particle.size / config.maxSize); // Larger particles rotate slower
          const rotation = `rotate(${particle.angle}deg)`;
          particle.element.style.transform = rotation;
        }
        
        // Update particle position
        particle.element.style.left = `${particle.x}px`;
        particle.element.style.top = `${particle.y}px`;
      });
      
      requestAnimationFrame(animateParticles);
    }
    
    // Mouse interaction
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      isMouseMoving = true;
      
      // Reset the timeout on each mouse move
      clearTimeout(mouseMovingTimeout);
      mouseMovingTimeout = setTimeout(() => {
        isMouseMoving = false;
      }, 2000); // Consider mouse stopped after 2 seconds of inactivity
    });
    
    // Touch interaction
    document.addEventListener('touchmove', (e) => {
      if (e.touches[0]) {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
        isMouseMoving = true;
        
        // Reset the timeout on each touch move
        clearTimeout(mouseMovingTimeout);
        mouseMovingTimeout = setTimeout(() => {
          isMouseMoving = false;
        }, 2000);
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      particles.forEach(particle => {
        // Keep particles within the new window bounds
        if (particle.x > window.innerWidth) {
          particle.x = window.innerWidth * Math.random();
          particle.baseX = particle.x;
        }
        
        if (particle.y > window.innerHeight) {
          particle.y = window.innerHeight * Math.random();
          particle.baseY = particle.y;
        }
      });
    });
    
    // Control event listeners
    document.getElementById('particle-count').addEventListener('input', function() {
      config.count = parseInt(this.value);
      countValue.textContent = config.count;
      
      // Update particle count
      const currentCount = particles.length;
      
      if (currentCount < config.count) {
        // Add more particles
        for (let i = 0; i < config.count - currentCount; i++) {
          createParticle();
        }
      } else if (currentCount > config.count) {
        // Remove excess particles
        for (let i = 0; i < currentCount - config.count; i++) {
          const particle = particles.pop();
          if (particle && particle.element) {
            particle.element.remove();
          }
        }
      }
      
      particleCountDisplay.textContent = particles.length;
    });
    
    document.getElementById('min-size').addEventListener('input', function() {
      config.minSize = parseInt(this.value);
      updateSizeDisplay();
    });
    
    document.getElementById('max-size').addEventListener('input', function() {
      config.maxSize = parseInt(this.value);
      updateSizeDisplay();
    });
    
    function updateSizeDisplay() {
      sizeValue.textContent = `${config.minSize}-${config.maxSize}px`;
    }
    
    document.getElementById('speed').addEventListener('input', function() {
      config.speed = parseFloat(this.value);
      speedValue.textContent = config.speed;
      
      // Update particle speeds
      particles.forEach(particle => {
        particle.speedX = (Math.random() * 2 - 1) * config.speed;
        particle.speedY = (Math.random() * 2 - 1) * config.speed;
      });
    });
    
    document.getElementById('interaction-radius').addEventListener('input', function() {
      config.interactionRadius = parseInt(this.value);
      interactionValue.textContent = `${config.interactionRadius}px`;
    });
    
    // Color preset selection
    document.querySelectorAll('.color-preset').forEach(preset => {
      preset.addEventListener('click', function() {
        // Update active state
        document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
        this.classList.add('active');
        
        // Update colors
        const colors = this.getAttribute('data-colors').split(',');
        config.colors = colors;
        
        // Update existing particles
        particles.forEach(particle => {
          const newColor = config.colors[Math.floor(Math.random() * config.colors.length)];
          particle.color = newColor;
          
          if (particle.shape === 'triangle') {
            particle.element.style.borderBottomColor = newColor;
          } else {
            particle.element.style.backgroundColor = newColor;
          }
        });
      });
    });
    
    // Shape selection
    document.querySelectorAll('.shape-option').forEach(option => {
      option.addEventListener('click', function() {
        // Toggle active state
        this.classList.toggle('active');
        
        // Update shapes array
        const shape = this.getAttribute('data-shape');
        if (this.classList.contains('active')) {
          // Add shape if not already in array
          if (!config.shapes.includes(shape)) {
            config.shapes.push(shape);
          }
        } else {
          // Remove shape from array
          const index = config.shapes.indexOf(shape);
          if (index > -1) {
            config.shapes.splice(index, 1);
          }
        }
        
        // Ensure at least one shape is selected
        if (config.shapes.length === 0) {
          config.shapes = ['circle'];
          document.querySelector('.shape-option[data-shape="circle"]').classList.add('active');
        }
      });
    });
    
    // Initialize
    createParticles();
    requestAnimationFrame(animateParticles);
  });
</script>
</body>
</html>